#include "stdinc.h"
#include "SliceAlgorithm.h"

#include "TermList.h"
#include "Term.h"
#include "VarNames.h"
#include "io.h"
#include "TermTranslator.h"
#include "Ideal.h"

unsigned int level = 0;
vector<unsigned int> calls;

SliceAlgorithm::SliceAlgorithm(const Ideal& ideal,
			       const VarNames& names,
			       const TermTranslator* translator,
			       ostream& out):
  _names(names),
  _translator(translator),
  _out(out) {

  // TODO: improve output configurability.
  _ioHandler = IOHandler::createIOHandler("monos");
  _ioHandler->startWritingIdeal(_out, _names);

  if (!ideal.isZeroIdeal()) {
    TermList subtract(ideal.getVariableCount());
    Term multiply(ideal.getVariableCount());
    
    content(ideal, subtract, multiply);
  }

  _ioHandler->doneWritingIdeal(_out);
  _out << flush;

  unsigned int sum = 0;
  for (unsigned int level = 0; level < calls.size(); ++level) {
    sum += calls[level];
    cerr << "Level " << level + 1 << " had "
	 << calls[level] << " calls. " << endl;
  }
  cerr << endl << "Sum: " << sum << endl;
}

void SliceAlgorithm::content(const Ideal& ideal,
			     const Ideal& subtract,
			     const Term& multiply) {
  if (calls.size() == level)
    calls.push_back(0);
  ++calls[level];
  ++level;

  //ideal.print();
  if (baseCase(ideal, subtract, multiply)) {
    --level;
    //    cerr << "was basecase" << endl;
    return;
  }

  Term pivot(ideal.getVariableCount());
  getPivot(ideal, subtract, pivot);

  //  cerr << "pivot: " << pivot << endl;

  // Handle inner slice
  //  cerr << "inner slice" << endl;
  Ideal* innerIdeal = ideal.createMinimizedColon(pivot);
  Ideal* innerSubtract = subtract.createMinimizedColon(pivot);
  Term innerMultiply(ideal.getVariableCount());
  innerMultiply.product(multiply, pivot);

  simplify(*innerIdeal, innerMultiply);
  content(*innerIdeal, *innerSubtract, innerMultiply);

  delete innerIdeal;
  delete innerSubtract;

  // Handle outer slice
  //  cerr << "outer slice" << endl;
  Ideal* outerIdeal = ideal.clone();
  Ideal* outerSubtract = subtract.clone();
  Term outerMultiply(multiply);
  outerSubtract->insert(pivot);
  outerIdeal->removeStrictMultiples(pivot);

  simplify(*outerIdeal, outerMultiply);
  content(*outerIdeal, *outerSubtract, outerMultiply);

  delete outerIdeal;
  delete outerSubtract;
  
  //  cerr << "returnin" << endl;
  --level;
}

void SliceAlgorithm::getPivot(const Ideal& ideal,
			      const Ideal& subtract,
			      Term& pivot) {
  ASSERT(!ideal.isZeroIdeal());
  /*
    pivot.setToZero();
    for (Ideal::const_iterator it = ideal.begin();
    it != ideal.end(); ++it) {
    bool squareFree = true;
    for (size_t i = 0; i < ideal.getVariableCount(); ++i)
    if ((*it)[i] > 1)
    squareFree = false;

    if (!squareFree) {
    pivot = *it;
    break;
    }
    }

    for (size_t i = 0; i < ideal.getVariableCount(); ++i)
    if (pivot[i] > 0)
    pivot[i] -= 1;
  */
  
  Term lcm(ideal.getVariableCount());
  ideal.getLcm(lcm);

  size_t maxOffset = 0;
  for (size_t i = 1; i < ideal.getVariableCount(); ++i)
    if (lcm[i] > lcm[maxOffset])
      maxOffset = i;
  
  pivot.setToZero();
  if (lcm[maxOffset] > 3)
    pivot[maxOffset] = lcm[maxOffset] / 3;
  else
    pivot[maxOffset] = lcm[maxOffset] / 2;
  
  ASSERT(pivot[maxOffset] > 0); 
  ASSERT(!ideal.contains(pivot));
  ASSERT(!subtract.contains(pivot));
}

bool SliceAlgorithm::baseCase(const Ideal& ideal,
			      const Ideal& subtract,
			      const Term& multiply) {
  if (ideal.isZeroIdeal())
    return true;

  Term lcm(ideal.getVariableCount());
  ideal.getLcm(lcm);

  // Check that each variable appears in some minimal generator.
  for (size_t i = 0; i < ideal.getVariableCount(); ++i)
    if (lcm[i] == 0)
      return true; // i can have no label, so no content

  // Ensure that ideal is square free.
  for (size_t i = 0; i < ideal.getVariableCount(); ++i)
    if (lcm[i] > 1)
      return false; // not square free

  // Check that ideal is generated by powers of single variables.
  if (ideal.getGeneratorCount() == ideal.getVariableCount()) {
    for (Ideal::const_iterator it = ideal.begin(); it != ideal.end(); ++it) {
      int variablesSeen = 0;
      for (size_t i = 0; i < ideal.getVariableCount(); ++i)
	if ((*it)[i] > 0)
	  ++variablesSeen;
      if (variablesSeen != 1)
	return true;
    }
  }

  vector<const char*> tmp(ideal.getVariableCount());
  for (unsigned int var = 0; var < ideal.getVariableCount(); ++var)
    tmp[var] = (_translator->getExponentString(var, multiply[var] + 1));
  _ioHandler->writeGeneratorOfIdeal(_out, tmp, _names);
  
  return true;
}

void SliceAlgorithm::simplify(Ideal& ideal, Term& multiply) const {
  Term gcd(ideal.getVariableCount());
  ideal.getGcd(gcd);
  ideal.colon(gcd);

  while (true) {
    Term lcm(ideal.getVariableCount());
    for (size_t offset = 0; offset < ideal.getVariableCount(); ++offset) {
      Term tmp(ideal.getVariableCount());
      bool first = true;
      for (Ideal::const_iterator it = ideal.begin();
	   it != ideal.end(); ++it) {
	if ((*it)[offset] == 0)
	  continue;
	if (first) {
	  tmp = *it;
	  first = false;
	} else
	  tmp.gcd(tmp, *it);
      }
      if (!first) {
	tmp[offset] -= 1;
	lcm.lcm(lcm, tmp);
      }
    }    
    
    if (!lcm.isZero()) {
      ideal.colon(lcm);
      ideal.minimize();
      multiply.product(multiply, lcm);
    } else
      break;
  }
}
