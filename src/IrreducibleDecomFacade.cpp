#include "stdinc.h"
#include "IrreducibleDecomFacade.h"

#include "label/FrobeniusStrategy.h"
#include "label/BenchmarkStrategy.h"
#include "label/DecompositionStrategy.h"
#include "label/LabelAlgorithm.h"

#include "IOHandler.h"
#include "IrreducibleDecomParameters.h"
#include "BigIdeal.h"
#include "IOFacade.h"
#include "VarNames.h"
#include "TermTranslator.h"
#include "Ideal.h"
#include "SliceAlgorithm.h"
#include "SliceStrategy.h"
#include "TermIgnorer.h"
#include "DecomRecorder.h"
#include "TermGrader.h"
#include "TermConsumer.h"
#include "IdealFacade.h"

IrreducibleDecomFacade::
IrreducibleDecomFacade(bool printActions,
		       const IrreducibleDecomParameters& parameters):
  Facade(printActions),
  _parameters(parameters) {
}

void IrreducibleDecomFacade::
computeIrreducibleDecom(Ideal& ideal, TermConsumer* consumer) {
  computeIrreducibleDecom(ideal, consumer, false);
}

void IrreducibleDecomFacade::
computeIrreducibleDecom(Ideal& ideal,
						TermConsumer* consumer,
						bool preMinimized) {
  if (!_parameters.getMinimal() && !preMinimized) {
	beginAction("Minimizing input ideal.");
	ideal.minimize();
	endAction();
  }

  beginAction("Computing irreducible decomposition.");

  if (ideal.contains(Term(ideal.getVarCount()))) {
	consumer->consume(Term(ideal.getVarCount()));
	delete consumer;
  } else if (_parameters.getUseSlice()) {
    SliceStrategy* strategy =
      SliceStrategy::newDecomStrategy(_parameters.getSplit(), consumer);    
    runSliceAlgorithm(ideal, strategy);
  } else {
    Strategy* strategy =
      new DecompositionStrategy(consumer, ideal.getVarCount());
    runLabelAlgorithm(ideal, strategy);
  }

  endAction();
}

void IrreducibleDecomFacade::
computeIrreducibleDecom(BigIdeal& bigIdeal, FILE* out, const string& format) {
  beginAction("Preparing to compute irreducible decomposition.");

  if (!_parameters.getUseSlice()) {
    // Special case for when the ideal is all of the ring, i.e. minimally
    // generated by the monomial 1. Also special case for when there is only
    // one variable.
    if (bigIdeal.getVarCount() <= 1 ||
		(bigIdeal.getGeneratorCount() == 1 &&
		 bigIdeal[0] == vector<mpz_class>(bigIdeal.getVarCount()))) {
      IOFacade ioFacade(false);
      ioFacade.writeIdeal(out, bigIdeal, format);
      return;
    }
  }

  Ideal ideal(bigIdeal.getVarCount());
  TermTranslator translator(bigIdeal, ideal);
  bigIdeal.clear();

  if (ideal.getGeneratorCount() > 0)
    translator.addArtinianPowers(ideal);

  TermConsumer* consumer;
  if (_parameters.getDoBenchmark())
    consumer = new TermIgnorer();
  else
    consumer = IOHandler::getIOHandler(format)->
      createWriter(out, &translator);
  
  endAction();

  computeIrreducibleDecom(ideal, consumer, false);
}

void IrreducibleDecomFacade::
computeAlexanderDual(BigIdeal& bigIdeal,
					 const vector<mpz_class>& point,
					 FILE* out, const string& format) {
  ASSERT(point.size() == bigIdeal.getVarCount());
  computeAlexanderDual(bigIdeal, point, false, out, format);
}

void IrreducibleDecomFacade::
computeAlexanderDual(BigIdeal& bigIdeal, FILE* out, const string& format) {
  vector<mpz_class> dummy;
  computeAlexanderDual(bigIdeal, dummy, true, out, format);
}

void IrreducibleDecomFacade::
computeAlexanderDual(BigIdeal& bigIdeal,
					 const vector<mpz_class>& pointParameter,
					 bool useLcm,
					 FILE* out,
					 const string& format) {
  if (!_parameters.getUseSlice()) {
	// This is to avoid having to deal with the special cases the
	// implementation of the label algorithm do not deal with itself.
	fputs("ERROR: Only the slice algorithm can be used to compute "
		  "the Alexander dual", stderr);
	exit(1);
  }

  // We have to remove the non-minimal generators before we take the
  // lcm, since the Alexander dual works on the lcm of only the
  // minimal generators.
  if (!_parameters.getMinimal()) {
	IdealFacade facade(isPrintingActions());
	facade.sortAllAndMinimize(bigIdeal);
  }

  beginAction("Preparing to compute Alexander dual.");

  vector<mpz_class> lcm(bigIdeal.getVarCount());
  bigIdeal.getLcm(lcm);

  vector<mpz_class> point;

  if (useLcm)
	point = lcm;
  else {
	ASSERT(pointParameter.size() == bigIdeal.getVarCount());
	point = pointParameter;
	for (size_t var = 0; var < bigIdeal.getVarCount(); ++var) {
	  if (point[var] < lcm[var]) {
		fputs("ERROR: The specified point to dualize on is not divisible by the\n"
			  "least common multiple of the minimal generators of the ideal.\n", stderr);
		exit(1);
	  }
	}
  }

  Ideal ideal(bigIdeal.getVarCount());
  TermTranslator translator(bigIdeal, ideal);
  translator.dualize(point);
  bigIdeal.clear();

  if (ideal.getGeneratorCount() > 0)
    translator.addArtinianPowers(ideal);

  TermConsumer* consumer;
  if (_parameters.getDoBenchmark())
    consumer = new TermIgnorer();
  else
    consumer = IOHandler::getIOHandler(format)->
      createWriter(out, &translator);

  endAction();

  computeIrreducibleDecom(ideal, consumer, true);
}

void IrreducibleDecomFacade::
computeFrobeniusNumber(const vector<mpz_class>& instance,
					   BigIdeal& bigIdeal, 
					   mpz_class& frobeniusNumber,
					   vector<mpz_class>& bigVector) {
  if (instance.size() == 2) {
    frobeniusNumber = instance[0] * instance[1] - instance[0] - instance[1];
	bigVector.resize(2);
	bigVector[0] = -1;
	bigVector[1] = instance[0] - 1;
    return;
  }
  
  beginAction("Preparing to compute Frobenius number.");
  Ideal ideal(bigIdeal.getVarCount());
  TermTranslator translator(bigIdeal, ideal, false);
  bigIdeal.clear();
  translator.addArtinianPowers(ideal);
  endAction();

  if (!_parameters.getMinimal()) {
	beginAction("Minimizing input ideal.");
	ideal.minimize();
	endAction();
  }

  beginAction("Optimizing over irreducible decomposition.");
  if (_parameters.getUseSlice()) {
	Ideal maxSolution(ideal.getVarCount());
    DecomRecorder recorder(&maxSolution);
    vector<mpz_class> shiftedDegrees(instance.begin() + 1, instance.end());
    TermGrader grader(shiftedDegrees, &translator);
    
    SliceStrategy* strategy = SliceStrategy::newFrobeniusStrategy
      (_parameters.getSplit(), &recorder, grader);
    
	runSliceAlgorithm(ideal, strategy);

	ASSERT(maxSolution.getGeneratorCount() == 1);
	Term solution(*maxSolution.begin(), maxSolution.getVarCount());
	grader.getDegree(solution, frobeniusNumber);
	bigVector.resize(instance.size());
	bigVector[0] = -1;
	for (size_t i = 0; i < instance.size(); ++i) {
	  frobeniusNumber -= instance[i];
	  if (i > 0)
		bigVector[i] = translator.getExponent(i - 1, solution) - 1;
	}
  } else {
    Strategy* strategy = new FrobeniusStrategy
      (instance, &frobeniusNumber, ideal.getVarCount(),
       &translator, _parameters.getUseBound());
    ASSERT(!_parameters.getUseIndependence());
    runLabelAlgorithm(ideal, strategy);
  }
  endAction();
}

void IrreducibleDecomFacade::
runSliceAlgorithm(Ideal& ideal, SliceStrategy* strategy) {
  ASSERT(strategy != 0);

  if (_parameters.getPrintStatistics())
    strategy = SliceStrategy::addStatistics(strategy);

  if (_parameters.getPrintDebug())
    strategy = SliceStrategy::addDebugOutput(strategy);

  SliceAlgorithm alg;
  alg.setUseIndependence(_parameters.getUseIndependence());
  alg.setStrategy(strategy);
  alg.runAndClear(ideal);
}

void IrreducibleDecomFacade::
runLabelAlgorithm(Ideal& ideal, Strategy* strategy) {
  ASSERT(strategy != 0);

  if (_parameters.getPrintStatistics())
    strategy = Strategy::addStatistics(strategy, ideal.getVarCount());

  if (_parameters.getPrintDebug())
    strategy = Strategy::addDebugOutput(strategy);

  if (_parameters.getSkipRedundant())
    strategy = Strategy::addSkipRedundant(strategy, ideal.getVarCount());

  // Run algorithm
  LabelAlgorithm algo;
  algo.setStrategy(strategy);
  algo.setUsePartition(_parameters.getUseIndependence());
  algo.runAndClear(ideal);
}
