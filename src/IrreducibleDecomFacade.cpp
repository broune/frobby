#include "stdinc.h"
#include "IrreducibleDecomFacade.h"

#include "PrintDebugStrategy.h"
#include "FrobeniusStrategy.h"
#include "BenchmarkStrategy.h"
#include "DecompositionStrategy.h"
#include "StatisticsStrategy.h"
#include "CompositeStrategy.h"
#include "PrintProgressStrategy.h"
#include "SkipRedundantStrategy.h"

#include "IrreducibleDecomParameters.h"
#include "BigIdeal.h"
#include "IOFacade.h"
#include "LabelAlgorithm.h"
#include "VarNames.h"
#include "TermTranslator.h"
#include "TermList.h"
#include "SliceAlgorithm.h"

IrreducibleDecomFacade::
IrreducibleDecomFacade(bool printActions,
		       const IrreducibleDecomParameters& parameters):
  Facade(printActions),
  _parameters(parameters) {
}

void IrreducibleDecomFacade::
computeIrreducibleDecom(BigIdeal& ideal, ostream& out) {
  beginAction("Computing irreducible decomposition using label algorithm.");

  ASSERT(ideal.getNames().getVarCount() >= 1);
  
  // Special case for when the ideal is all of the ring, i.e. minimally
  // generated by the monomial 1. Also special case for when there is only
  // one variable.
  if (ideal.getNames().getVarCount() == 1 ||
      (ideal.size() == 1 &&
       ideal[0] == vector<mpz_class>(ideal.getNames().getVarCount()))) {
    IOFacade ioFacade(false);
    ioFacade.writeIdeal(out, ideal);
    return;
  }

  TermTree* tree;
  TermTranslator* translator;
  ideal.buildAndClear(tree, translator, false);

  if (_parameters.getUseSlice()) {
    TermList terms(tree->getDimension());
    tree->getTerms(terms);
    SliceAlgorithm alg(terms, ideal.getNames(), translator);
  } else {
    Strategy* strategy;
    if (_parameters.getDoBenchmark())
      strategy = new BenchmarkStrategy();
    else
      strategy = new DecompositionStrategy
	(&out, ideal.getNames(), ideal.getNames().getVarCount(), translator);
    runAlgorithm(tree, translator, strategy);
  }

  endAction();
}

void IrreducibleDecomFacade::
computeFrobeniusNumber(const vector<mpz_class>& instance,
		       BigIdeal& ideal, 
		       mpz_class& frobeniusNumber) {
  beginAction
    ("Optimizing over irreducible decomposition using label algorithm.");

  if (_parameters.getSkipRedundant()) {
    cerr << "ERROR: Due to implementation issues, the Grobner basis" << endl
	 << "based Frobenius feature does not support independence splits."
	 << endl;
    exit(1);
  }

  if (instance.size() == 2) {
    frobeniusNumber = instance[0] * instance[1] - instance[0] - instance[1];
    return;
  }

  TermTree* tree;
  TermTranslator* translator;
  ideal.buildAndClear(tree, translator, false);

  Strategy* strategy = new FrobeniusStrategy
    (instance, &frobeniusNumber, ideal.getNames().getVarCount(),
     translator, _parameters.getUseBound());
  runAlgorithm(tree, translator, strategy);

  endAction();
}

// All parameters are deleted.
void IrreducibleDecomFacade::
runAlgorithm(TermTree* tree, TermTranslator* translator, Strategy* strategy) {
  ASSERT(strategy != 0);

  // Set up the combined strategy
  vector<Strategy*> strategies;
  strategies.push_back(strategy);

  if (_parameters.getPrintProgress())
    strategy = addStrategy(strategies, strategy, new PrintProgressStrategy());

  if (_parameters.getPrintStatistics())
    strategy = addStrategy
      (strategies, strategy,
       new StatisticsStrategy(tree->getDimension()));

  if (_parameters.getPrintDebug())
    strategy = addStrategy(strategies, strategy, new PrintDebugStrategy());

  if (_parameters.getSkipRedundant()) {
    strategy = 
      new SkipRedundantStrategy(strategy, tree->getDimension());
    strategies.push_back(strategy);
  }

  // Run algorithm
  LabelAlgorithm algo(strategy, tree, _parameters.getUsePartition());

  // Clean up afterwards
  for (vector<Strategy*>::iterator it = strategies.begin();
       it != strategies.end(); ++it)
    delete *it;

  delete tree;
  delete translator;
}

Strategy* IrreducibleDecomFacade::
addStrategy(vector<Strategy*>& strategies,
	    Strategy* oldStrategy,
	    Strategy* newStrategy) {
  ASSERT(oldStrategy != 0);
  ASSERT(newStrategy != 0);
  
  Strategy* composite = new CompositeStrategy(oldStrategy, newStrategy);

  strategies.push_back(oldStrategy);
  strategies.push_back(composite);

  return composite;
}
